rm(list=ls())
library(RAutoDiff)
n <- 5
set.seed(2)
y <- rnorm(n)
d <- 2

target <- function(q){
  lp <- sum(dnorm(y,q[1],exp(0.5*q[2]),log=TRUE))
  G <- diag(n*c(exp(-q[2]),0.5)) # Fisher information
  return(list(lp=lp,G=G))
}

Hamiltonian <- function(z){
  q <- z[1:d]
  p <- z[(d+1):(2*d)]
  t <- target(q)
  return(-t$lp - mvnorm_lpdf_var(p,rep(0,d),t$G))
}

H.ode <- function(q,p){
  z.a <- independent(c(q,p))
  h.a <- Hamiltonian(z.a)
  grad <- gradient(h.a)
  return(c(grad[(d+1):(2*d)],-grad[1:d])) 
}


lambda <- 1.0/(pi/2)
Tmax <- 500
n.samples <- 1000


ode <- function(t,y,params){
  q <- y[1:d]
  p <- y[(d+1):(2*d)]
  
  force <- c(H.ode(q,p),lambda,0.0,q,q^2,q[1]*q[2])
  return(list(force))
}

# Event occurs when this function equals 0
rootfun <- function(t,y,params){
  return(y[2*d+2]-y[2*d+1]) # Lam target - Lam
}

# At event resampling
eventfun <- function(t,y,params){
  y.out <- y
  t <- target(y.out[1:d])
  y.out[(d+1):(2*d)] <- mvtnorm::rmvnorm(1,mean=rep(0,d),sigma=t$G) # refresh momentum
  y.out[2*d+1] <- 0.0 # reset integrated event rate
  y.out[2*d+2] <- rexp(1) # integrated event rate target
  return(y.out)
}


q0 <- rep(0,d)
t <- target(q0)


y0 <- c(q0, # initial q
        mvtnorm::rmvnorm(1,mean=rep(0,d),sigma=t$G), #initial p
        0.0, # initial Lam
        rexp(1), # initial Lam-target
        rep(0,2*d+1) # inital monitoring functions
)


times <- seq(from=0.0,to=Tmax,length.out = n.samples)

output <- deSolve::lsoda(y0,times=times,func=ode,
                         rootfunc=rootfun,
                         events=list(func=eventfun,root=TRUE))

plot(output[,2],output[,3],type="l")
